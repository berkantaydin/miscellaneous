diff --git a/src/mongo/util/net/listen.cpp b/src/mongo/util/net/listen.cpp
index 6e3babf..94c38e7 100644
--- a/src/mongo/util/net/listen.cpp
+++ b/src/mongo/util/net/listen.cpp
@@ -39,6 +39,7 @@
 #include <arpa/inet.h>
 #include <errno.h>
 #include <netdb.h>
+#include <time.h>
 #ifdef __openbsd__
 # include <sys/uio.h>
 #endif
@@ -51,6 +52,23 @@
 
 #endif
 
+// Make sure our Linux has the timer we need
+#if defined(__linux__)
+    #ifndef CLOCK_MONOTONIC_COARSE
+        #error "Your ancient kernel doesn't support CLOCK_MONOTONIC_COARSE: upgrade to v2.6.31 or newer"
+    #endif
+#endif
+
+// For absolute_time monotonic counters
+#if defined(__MACH__)
+    #include <mach/mach_time.h>
+#endif
+
+// For monotonic performance counters
+#if defined(_WIN32)
+    #include <windows.h>
+#endif
+
 namespace mongo {
 
 
@@ -97,7 +115,7 @@ namespace mongo {
     }
     
     Listener::Listener(const string& name, const string &ip, int port, bool logConnect ) 
-        : _port(port), _name(name), _ip(ip), _logConnect(logConnect), _elapsedTime(0) { 
+        : _port(port), _name(name), _ip(ip), _logConnect(logConnect) {
 #ifdef MONGO_SSL
         _ssl = getSSLManager();
 #endif
@@ -203,7 +221,7 @@ namespace mongo {
         _logListen(_port, false);
 #endif
 
-        struct timeval maxSelectTime;
+        this->startElapsedTimeCounter();
         while ( ! inShutdown() ) {
             fd_set fds[1];
             FD_ZERO(fds);
@@ -212,16 +230,9 @@ namespace mongo {
                 FD_SET(*it, fds);
             }
 
-            maxSelectTime.tv_sec = 0;
-            maxSelectTime.tv_usec = 10000;
-            const int ret = select(maxfd+1, fds, NULL, NULL, &maxSelectTime);
+            const int ret = select(maxfd+1, fds, NULL, NULL, NULL);
 
             if (ret == 0) {
-#if defined(__linux__)
-                _elapsedTime += ( 10000 - maxSelectTime.tv_usec ) / 1000;
-#else
-                _elapsedTime += 10;
-#endif
                 continue;
             }
 
@@ -238,12 +249,6 @@ namespace mongo {
                 return;
             }
 
-#if defined(__linux__)
-            _elapsedTime += max(ret, (int)(( 10000 - maxSelectTime.tv_usec ) / 1000));
-#else
-            _elapsedTime += ret; // assume 1ms to grab connection. very rough
-#endif
-
             for (vector<SOCKET>::iterator it=socks.begin(), end=socks.end(); it != end; ++it) {
                 if (! (FD_ISSET(*it, fds)))
                     continue;
@@ -555,6 +560,55 @@ namespace mongo {
         globalTicketHolder.resize( want );
     }
 
+    #if defined(_WIN32)
+    long long Listener::getWinPerformanceFrequency() {
+        long long counter_freq = -1;
+        QueryPerformanceFrequency(&counter_freq);
+        return counter_freq;
+    }
+
+    void Listener::winPerformanceCounterToMillis(long long *t) {
+        static long long counter_freq = getWinPerformanceFrequency();
+        *t /= counter_freq / 1000;
+    }
+    #endif
+
+    #if defined(__MACH__)
+    mach_timebase_info_data_t Listener::getMachTimeInfo() {
+        mach_timebase_info_data_t x;
+        mach_timebase_info(&x);
+        return x;
+    }
+
+    void Listener::machAbsToMillis(long long *t) {
+        static mach_timebase_info_data_t conv = getMachTimeInfo();
+        *t *= conv.numer;
+        *t /= conv.denom;
+        *t /= 1000000;
+    }
+    #endif
+
+    long long Listener::getMillis() {
+        long long now = -1;
+
+        #if defined(__linux__)
+            struct timespec n;
+            clock_gettime(CLOCK_MONOTONIC_COARSE, &n);
+            now = n.tv_sec * 1000 + n.tv_nsec / 1000000;
+        #elif defined(_WIN32)
+            QueryPerformanceCounter(&now);
+            winPerformanceCounterToMillis(&now);
+        #elif defined(__MACH__)
+            now = mach_absolute_time();
+            machAbsToMillis(&now);
+        #elif defined(__sunos__)
+            now = gethrtime() / 1000000;
+        #else
+            #error "Don't know how to get monotonic time on this platform!"
+        #endif
+
+        return now;
+    }
 
     TicketHolder Listener::globalTicketHolder(DEFAULT_MAX_CONN);
     AtomicInt64 Listener::globalConnectionNumber;
diff --git a/src/mongo/util/net/listen.h b/src/mongo/util/net/listen.h
index 843cfa7..1b84f7d 100644
--- a/src/mongo/util/net/listen.h
+++ b/src/mongo/util/net/listen.h
@@ -21,6 +21,11 @@
 #include "mongo/util/concurrency/ticketholder.h"
 #include "mongo/util/net/sock.h"
 
+// For Mach monotonic counters (need for return type of helper function)
+#if defined(__MACH__)
+    #include <mach/mach_time.h>
+#endif
+
 namespace mongo {
 
     const int DEFAULT_MAX_CONN = 20000;
@@ -44,9 +49,9 @@ namespace mongo {
         const int _port;
 
         /**
-         * @return a rough estimate of elapsed time since the server started
+         * @return elapsed time since the server started, in milliseconds
          */
-        long long getMyElapsedTimeMillis() const { return _elapsedTime; }
+        long long getMyElapsedTimeMillis() const { return getMillis() - startMillis; }
 
         void setAsTimeTracker() {
             _timeTracker = this;
@@ -64,11 +69,16 @@ namespace mongo {
             return 0;
         }
 
+        /**
+         * @start the elapsed time counter
+         */
+        void startElapsedTimeCounter() { startMillis = getMillis(); }
+
     private:
         string _name;
         string _ip;
         bool _logConnect;
-        long long _elapsedTime;
+        long long startMillis;
         
 #ifdef MONGO_SSL
         SSLManager* _ssl;
@@ -85,6 +95,18 @@ namespace mongo {
         
         virtual bool useUnixSockets() const { return false; }
 
+        #if defined(_WIN32)
+        static long long getWinPerformanceFrequency();
+        static void winPerformanceCounterToMillis(long long *t);
+        #endif
+
+        #if defined(__MACH__)
+        static mach_timebase_info_data_t getMachTimeInfo();
+        static void machAbsToMillis(long long *t);
+        #endif
+
+        static long long getMillis();
+
     public:
         /** the "next" connection number.  every connection to this process has a unique number */
         static AtomicInt64 globalConnectionNumber;
